from cmu_112_graphics import *
import random, copy, csv

                                                                  
# Helper that makes a 2d list of row x col
def make2dList(rows, cols, fill=0):
    return [ ([fill] * cols) for row in range(rows) ] 

def almostEqual(d1, d2, epsilon=10**-7): #helper-fn
    # note: use math.isclose() outside 15-112 with Python version 3.5 or later
    return (abs(d2 - d1) < epsilon)

import decimal
def roundHalfUp(d): #helper-fn
    # Round to nearest with ties going away from zero.
    rounding = decimal.ROUND_HALF_UP
    # See other rounding options here:
    # https://docs.python.org/3/library/decimal.html#rounding-modes
    return int(decimal.Decimal(d).to_integral_value(rounding=rounding))

# Takes in string and makes a list from a string that looks like one
def makeListFromString(s):
    isWord = False
    result = []
    currentWord = ""
    for c in s:
        if isWord:
            currentWord += c

        if c == "," and isWord:
            result.append(currentWord[2:-2])
            currentWord = ""
            isWord = not isWord
        elif c == ",":
            isWord = not isWord
    return result

# Helper to select 4 distinct moves that do damage
def selectMoves(moveSet, i):
    addedMoves = [""] * i
    while i > 0:
        move = moveSet[random.randint(0, len(moveSet)-1)]
        temp = ""
        for word in move.split("'"):
            temp += word + "-"
        temp = temp[:-1]
        move = temp
        if not (move in addedMoves) and moveList[move]["Power"] != "None":
            addedMoves[i-1] = move
            i -= 1
    return addedMoves

###############################################################################
###############################################################################
# _________    _____________   ____    __________
# \_   ___ \  /   _____/\   \ /   /    \______   \_____  _______  ______  ____
# /    \  \/  \_____  \  \   Y   /      |     ___/\__  \ \_  __ \/  ___/_/ __ \
# \     \____ /        \  \     /       |    |     / __ \_|  | \/\___ \ \  ___/
#  \______  //_______  /   \___/        |____|    (____  /|__|  /____  > \___  >
#         \/         \/                                \/            \/      \/
###############################################################################
###############################################################################

pokemonList = dict()
with open("pokemon-data.csv", "r") as file:
    csvreader = csv.reader(file, delimiter=";")
    for pokemon in csvreader:
        pokemonList[pokemon[0]] = {
            "Type": pokemon[1],
            "Abilities": makeListFromString(pokemon[2]),
            "HP": (pokemon[4]),
            "Attack": (pokemon[5]),
            "Defense": (pokemon[6]),
            "Special Attack": (pokemon[7]),
            "Special Defense": (pokemon[8]),
            "Speed": (pokemon[9]),
            "Evolution": pokemon[10],
            "Move Set": makeListFromString(pokemon[11])
        }

moveList = dict()
with open("move-data.csv", "r") as file:
    csvreader = csv.reader(file, delimiter=",")
    for move in csvreader:
        moveList[move[1]] = {
            "Type": move[2],
            "Category": move[3],
            "PP": move[5],
            "Power": move[6],
            "Accuracy": move[7]
        }

###############################################################################
###############################################################################
# _________  .__                                            
# \_   ___ \ |  |  _____     ______  ______  ____    ______ 
# /    \  \/ |  |  \__  \   /  ___/ /  ___/_/ __ \  /  ___/ 
# \     \____|  |__ / __ \_ \___ \  \___ \ \  ___/  \___ \  
#  \______  /|____/(____  //____  >/____  > \___  >/____  > 
#         \/            \/      \/      \/      \/      \/  
###############################################################################
###############################################################################                                                         

# Player Object
class Player(object):
     def __init__(self, row, col, image):
        self.row = row
        self.col = col
        self.facing = 0 # 0: Up, 1: Left, 2: Right, 3: Down
        # Split sprite sheet into 2d array of all sprite images
        self.sprites = make2dList(4, 4)
        for row in range(4):
            for col in range(4):
                sprite = image.crop((64*col, 64*row, 64*(col+1), 64*(row+1)))
                self.sprites[row][col] = sprite
        self.ownedPokemon = []
        pok = "Serperior"
        self.ownedPokemon.append(Pokemon(200, pok, pokemonList[pok]))

class Pokemon(object):
    def __init__(self, level, name, stats):
        self.name = name
        self.type = stats["Type"]
        self.lvl = level
        # Get move set for this instance
        moveSet = stats["Move Set"]
        self.moves = selectMoves(moveSet, 4)
        # Stats
        self.baseHP , self.modHP = int(stats["HP"]), 2       
        self.hp = roundHalfUp(self.baseHP + self.lvl * self.modHP)
        self.baseATK, self.modATK = int(stats["Attack"]), 1.1 
        self.attack = roundHalfUp(self.baseATK + self.lvl * self.modATK)
        self.baseSPATK, self.modSPATK = int(stats["Special Attack"]), 1.1 
        self.SPattack = roundHalfUp(self.baseSPATK + self.lvl * self.modSPATK)
        self.baseDEF, self.modDEF = int(stats["Defense"]), 0.5 
        self.defense = roundHalfUp(self.baseDEF + self.lvl * self.modDEF)
        self.baseSPDEF, self.modSPDEF = int(stats["Special Defense"]), 0.5 
        self.SPdefense = roundHalfUp(self.baseSPDEF + self.lvl * self.modSPDEF)
        self.baseSPD, self.modSPD = int(stats["Speed"]), 1.1 
        self.speed = roundHalfUp(self.baseSPD + self.lvl * self.modSPD)
    
    def getMaxHP(self):
        return roundHalfUp(self.baseHP + self.lvl * self.modHP)    

    def __repr__(self):
        return(
        f"\n{self.name}"
        f"\nlevel={self.lvl}, type={self.type},"
        f"\nmoves={self.moves}"
        f"\nhp={self.hp}, atk={self.attack}, spatk={self.SPattack}, df="
        f"{self.defense}, spdf={self.SPdefense}, sp={self.speed}"
        f"\n")

def createRandPokemon(app):
    pok = random.choice(list(pokemonList.keys()))
    return Pokemon(40, pok, pokemonList[pok])


###############################################################################
###############################################################################
#   _________  __                    __    
#  /   _____/_/  |_ _____  _______ _/  |_  
#  \_____  \ \   __\\__  \ \_  __ \\   __\ 
#  /        \ |  |   / __ \_|  | \/ |  |   
# /_______  / |__|  (____  /|__|    |__|   
#         \/             \/                
###############################################################################
###############################################################################                                      

# Initialize all variables
def appStarted(app):
    app.score = 0
    app.mode = "startMode"
    if app.mode == "overworldMode":
        startOverworld(app)
    elif app.mode == "battleMode":
        startBattle(app)

# If click in button, gen map and allow movement
def startMode_mousePressed(app, event):
    if inButton(app, event.x, event.y):
        startOverworld(app)
        app.mode = "overworldMode"

# Checks if given cords are in button
def inButton(app, x, y):
    if (app.width/2-95 <= x <= app.width/2+95 and 
       app.height*2/3-45 <= y <= app.height*2/3+45):
        return True
    return False

def startMode_redrawAll(app, canvas):
    # Draws name of game
    font = "ComicSansMs 100 bold"
    canvas.create_text(app.width/2, app.height/2, text="Pokemon 112", 
                       font=font, fill="black")
    drawButton(app, canvas)

# Draws the button below the text
def drawButton(app, canvas):
    w = 190
    h = 90
    x = app.width/2
    y = app.height*2/3
    canvas.create_rectangle(x-w/2, y-h/2, x+w/2, y+h/2, fill="yellow green", 
                            width=6, outline="forest green")
    font = "ComicSansMS 60"
    canvas.create_text(x, y, text="Start", font=font, fill="black")



###############################################################################
###############################################################################
# ________                                               .__       .___ 
# \_____  \ ___  __  ____ _______ __  _  __ ____ _______ |  |    __| _/ 
#  /   |   \\  \/ /_/ __ \\_  __ \\ \/ \/ //  _ \\_  __ \|  |   / __ |  
# /    |    \\   / \  ___/ |  | \/ \     /(  <_> )|  | \/|  |__/ /_/ |  
# \_______  / \_/   \___  >|__|     \/\_/  \____/ |__|   |____/\____ |  
#         \/            \/                                          \/  
###############################################################################
###############################################################################                                                             

def startOverworld(app):
    # Board properties
    app.shownRowsCols = 11
    app.tileSize = app.width // app.shownRowsCols
    app.rows = 60
    app.cols = 60
    app.encounterChance = 10
    # Player Properties
    playerImage = app.loadImage('./TrainerSprites/trchar170.png')
    app.player = Player(app.rows//2, app.cols//2, playerImage)
    # Create Board fills
    app.grid = make2dList(app.rows, app.cols)
    createGridFills(app)
    # Images
    size = 32
    app.g, app.w, app.r = createImagesOverworld(app, size)

def createImagesOverworld(app, s):
    images = []
    for c, r in [(3, 2), (0, 3)]:
        orig = app.loadImage('./TileSprites/TileSheet3.png').crop((s*c, s*r, s*(c+1), s*(r+1)))
        scale = (app.tileSize/orig.size[0])
        images.append(app.scaleImage(orig, scale))
    c, r = 7, 146
    orig = app.loadImage('./TileSprites/TileSheet1.png').crop((s*c, s*r, s*(c+1), s*(r+1)))
    scale = (app.tileSize/orig.size[0])
    images.append(app.scaleImage(orig, scale))
    return images

# Initialize the fill of grid 
def createGridFills(app):
    for row in range(len(app.grid)):
        for col in range(len(app.grid[0])):
            value = random.randint(0, 2)
            app.grid[row][col] = value
    for row in range(-3, 4):
        for col in range(-3, 4):
            app.grid[app.player.row+row][app.player.col+col] = 0

def overworldMode_keyPressed(app, event):
    # Initial move is 0, 0
    dMove = (0, 0)
    # Max rows/cols
    borderTop = app.shownRowsCols//2
    borderBot = app.rows - app.shownRowsCols//2 - 1
    borderLeft = app.shownRowsCols//2
    borderRight = app.cols - app.shownRowsCols//2 - 1
    
    # If player is facing in move direction, move in that direction, 
    # change facing either way
    if event.key == "Up":
        if app.player.facing == 3:
            dMove = (-1, 0)
        app.player.facing = 3
    elif event.key == "Down":
        if app.player.facing == 0:
            dMove = (1, 0)
        app.player.facing = 0
    elif event.key == "Right":
        if app.player.facing == 2:
            dMove = (0, 1)
        app.player.facing = 2
    elif event.key == "Left":
        if app.player.facing == 1:
            dMove = (0, -1)
        app.player.facing = 1
    elif event.key == "r":
        appStarted(app)

    # Test to see if collision with rock or border
    app.player.row += dMove[0]
    app.player.col += dMove[1]
    if (app.grid[app.player.row][app.player.col] == 2 or 
       app.player.row < borderTop or app.player.row > borderBot or
       app.player.col > borderRight or app.player.col < borderLeft):
        app.player.row -= dMove[0]
        app.player.col -= dMove[1]
    # Have a chance to start an encounter if player moves into grass
    elif (app.grid[app.player.row][app.player.col] == 1) and dMove != (0, 0):
        chance = random.randint(1, 100)
        if chance <= app.encounterChance:
            app.mode = "battleMode"
            startBattle(app)


def overworldMode_redrawAll(app, canvas):
    drawGrid(app, canvas)
    drawPlayer(app, canvas)
    drawElementOver(app, canvas)
    drawScore(app, canvas)

# Draws all tiles on the board through a 2d list
# By default all of these are drawn behind the player
def drawGrid(app, canvas):
    # Loop through all rows and cols
    for row in range(app.shownRowsCols):
        for col in range(app.shownRowsCols):
            # This is the row/col that should be indexed. 
            # Always relative to player, with player in center
            colorRow = app.player.row - (app.shownRowsCols//2) + row
            colorCol = app.player.col - (app.shownRowsCols//2) + col

            cx = (col+0.5)*app.tileSize
            cy = (row+0.5)*app.tileSize
            
            # All background tiles are light green images
            canvas.create_image(cx, cy, image=ImageTk.PhotoImage(app.w))
            # Create grass if grid is 1, and player is not on tile If player is 
            # on tile, draw grass over the player instead in drawTileElements
            if (app.grid[colorRow][colorCol] == 1 and not 
                 (app.player.row == colorRow and app.player.col == colorCol)):
                    canvas.create_image(cx, cy, image=ImageTk.PhotoImage(app.g))
            # Draw rock if value is 2
            elif app.grid[colorRow][colorCol] == 2:
                canvas.create_image(cx, cy, image=ImageTk.PhotoImage(app.r))
            
            # Debug code that will display the row,col values on each tile
                # text = "(" + str(colorRow) + ", " + str(colorCol) + ")"            
                # canvas.create_text((col+0.5)*app.tileSize, (row+0.5)*app.tileSize,
                #                     text=text)

# Draws the player using values from the Player class          
def drawPlayer(app, canvas):
    # Set properties of image, making it larger than 1 tile
    image = app.player.sprites[app.player.facing][0]
    scale = (app.tileSize/image.size[0])*1.6
    image = app.scaleImage(image, scale)
    # Always place char in the center of screen
    x = app.width/2
    y = app.height/2
    r = app.tileSize/2 * 0.8
    canvas.create_image(x, y-20, image=ImageTk.PhotoImage(image))
    
# Draw element over the character if char is on the tile
def drawElementOver(app, canvas):
    col = app.shownRowsCols // 2  
    row = app.shownRowsCols // 2 
    if app.grid[app.player.row][app.player.col] == 1:
        canvas.create_image((col+0.5)*app.tileSize, (row+0.5)*app.tileSize, 
                             image=ImageTk.PhotoImage(app.g))

# Draws score in top right
def drawScore(app, canvas):
    font = "ComicSansMS 20 bold"
    canvas.create_rectangle(app.width-100, 0, app.width, 30, fill="grey40", 
                            width=5, outline="grey69")
    canvas.create_text(app.width-10, 0, anchor="ne", font=font, 
                       text="Score: " + str(app.score), fill="black")


###############################################################################
###############################################################################
# __________          __     __   .__            
# \______   \_____  _/  |_ _/  |_ |  |    ____   
#  |    |  _/\__  \ \   __\\   __\|  |  _/ __ \  
#  |    |   \ / __ \_|  |   |  |  |  |__\  ___/  
#  |______  /(____  /|__|   |__|  |____/ \___  > 
#         \/      \/                         \/  
###############################################################################


# Sets up variables for battle
def startBattle(app):
    # Draw pokemon/background
    app.bgImage = createImagesBattle(app) 
    app.pokCloseX = app.width/4
    app.pokCloseY = app.bgImage.size[1]
    # Pokemon/Battle values
    pok2 = random.choice(list(pokemonList.keys()))
    index = random.randint(0, len(app.player.ownedPokemon)-1)
    while app.player.ownedPokemon[index].hp == 0:
            index = random.randint(0, len(app.player.ownedPokemon)-1)    
    app.pokClose = app.player.ownedPokemon[index]
    app.pokFar = Pokemon(40, pok2, pokemonList[pok2])
    initializeSprites(app)
    app.first, app.second, app.move0, app.move1 = -1, -1, -1, -1
    # Info box variables
    app.infoH, app.infoW = 100, app.width/2
    app.infoX = app.infoW
    app.infoY = app.height*5/13
    app.displayHPClose = app.pokClose.hp
    app.displayHPFar = app.pokFar.hp
    # Timer fired variables
    app.tickCount = 0
    app.timerDelay = 25
    # Text box values
    app.textBoxSize = 100
    app.newMessage = f"A wild {app.pokFar.name} appeared!"
    app.battleText = ""
    app.textSpeed = 1
    # Chosing
    app.selection = (0, 0)
    # State
    app.battleState = "Entering"    

def initializeSprites(app):
    urlClose = createValidPokemonClose(app)
    initialSpriteClose = app.loadImage(urlClose)
    scale = 180/initialSpriteClose.size[0]
    app.pokCloseSprite = app.scaleImage(initialSpriteClose, scale)
    app.pokCloseSprite.apply_transparency()

    urlFar = createValidPokemonFar(app)
    initialSpriteFar = app.loadImage(urlFar)
    scale = 120/initialSpriteClose.size[0]
    app.pokFarSprite = app.scaleImage(initialSpriteFar, scale)
    app.pokFarSprite.apply_transparency()

def createValidPokemonClose(app):
    found = False
    while not found:
        url = ("https://img.pokemondb.net/sprites/heartgold-soulsilver/" + 
                "back-normal/" + app.pokClose.name.lower() + ".png")
        try:
            app.loadImage(url)
        except:
            pok = random.choice(list(pokemonList.keys()))
            app.pokClose = Pokemon(40, pok, pokemonList[pok])
        else:
            found = True
    return url

def createValidPokemonFar(app):
    found = False
    while not found:
        url = ("https://img.pokemondb.net/sprites/heartgold-soulsilver/" + 
                "normal/" + app.pokFar.name.lower() + ".png")
        try:
            app.loadImage(url)
        except:
            pok = random.choice(list(pokemonList.keys()))
            app.pokFar = Pokemon(40, pok, pokemonList[pok])
        else:
            found = True
    return url
            

# Helper to create the background for the battle
def createImagesBattle(app):
    bg = app.loadImage('./TileSprites/BattleTiles.png').crop((6, 440, 256, 582))
    scale = (app.width/bg.size[0])
    return app.scaleImage(bg, scale)

# Draws all
def battleMode_redrawAll(app, canvas):
    drawBackground(app, canvas)
    drawInfoBox1(app, canvas)
    drawInfoBox2(app, canvas)
    drawPokemon(app, canvas)
    drawTextBox(app, canvas)
    # Only draw the moves if you state is choosing
    if app.battleState == "Choosing":
        drawMoves(app, canvas)

# Draws the image background that fills the width of screen
def drawBackground(app, canvas):
    canvas.create_image(app.width/2, app.bgImage.size[1]/2, 
                        image=ImageTk.PhotoImage(app.bgImage))

# Draws the infoBox for the close pokemon
def drawInfoBox1(app, canvas):
    m = 2
    font = "ComicSansMS 20"
    # Outer box
    canvas.create_rectangle(app.infoX, app.infoY, app.infoX+app.infoW, 
                            app.infoY+app.infoH, fill="grey85", width=m, 
                            outline="white")
    canvas.create_rectangle(app.infoX+m, app.infoY+m, app.infoX+app.infoW, 
                            app.infoY+m+10, fill="grey30", outline="grey30")
    canvas.create_text(app.infoX+20, app.infoY+20, anchor="nw", font=font, 
                       text=app.pokClose.name, fill="grey30") 
    # Level in top left
    canvas.create_text(app.width-10, app.infoY+20, anchor="ne", font=font,
                       text="Lv"+str(app.pokClose.lvl), fill="grey30") 
    # HP right before HP Bar
    canvas.create_text(app.infoX+140, app.infoY+50, anchor="ne", font=font,
                       text="HP", fill="grey30")

    # HP bar variab;es
    l = 150
    h = 10
    x0 = app.infoX+145
    y0 = app.infoY+60
    x1 = x0 + (l*(app.displayHPClose/app.pokClose.getMaxHP()))
    y1 = y0+h
    # Change HP bar color at certain thresholds
    if (app.displayHPClose/app.pokClose.getMaxHP()) > 0.5:
        fill = "green"
    elif (app.displayHPClose/app.pokClose.getMaxHP()) > 0.2:
        fill = "gold"
    else:
        fill = "red"
    # Create Hp bar
    canvas.create_rectangle(x0-m, y0-m, x0+l+m, y1+m, fill="white", width=0)
    canvas.create_rectangle(x0, y0, x1, y1, fill=fill, width=0)
    # Draw text of HP under hp bar
    HPtxt = str(app.pokClose.hp) + "/" + str(app.pokClose.getMaxHP())
    canvas.create_text((2*x0+2*m+l)/2, y1, anchor="n", text=HPtxt, fill="black")

# Draws info box for far pokemon (doesn't include exact health)
def drawInfoBox2(app, canvas):
    # Variables for box
    m = 2
    font = "ComicSansMS 20"
    x0 = 0
    y0 = 40
    # Draws outer box in top left
    canvas.create_rectangle(x0, y0, x0+app.infoW, 
                            y0+app.infoH, fill="grey85", width=m, 
                            outline="white")
    canvas.create_rectangle(x0+m, y0+m, x0+app.infoW, 
                           y0+m+10, fill="grey30", outline="grey30")
    canvas.create_text(x0+20, y0+20, anchor="nw", font=font, 
                       text=app.pokFar.name, fill="grey30") 
    # Draws level and HP before bar
    canvas.create_text(x0+app.infoW-10, y0+20, anchor="ne", font=font,
                       text="Lv"+str(app.pokFar.lvl), fill="grey30") 
    canvas.create_text(x0+140, y0+50, anchor="ne", font=font,
                       text="HP", fill="grey30")

    # Draws HP bar for far pokemon 
    l = 150
    h = 10
    x0 = x0+145
    y0 = y0+60
    x1 = x0 + (l*(app.displayHPFar/app.pokFar.getMaxHP()))
    y1 = y0+h
    # Changes color at thresholds
    if (app.displayHPFar/app.pokFar.getMaxHP()) > 0.5:
        fill = "green"
    elif (app.displayHPFar/app.pokFar.getMaxHP()) > 0.2:
        fill = "gold"
    else:
        fill = "red"
    # Draws HP bar
    canvas.create_rectangle(x0-m, y0-m, x0+l+m, y1+m, fill="white", width=0)
    canvas.create_rectangle(x0, y0, x1, y1, fill=fill, width=0)
    # Note: there is no hp exact for far as you shouldn't know health of far
    # pokemon

# Draws the pokemon on the background
def drawPokemon(app, canvas):
    canvas.create_image(app.pokCloseX, app.pokCloseY, anchor="s",
                            image=ImageTk.PhotoImage(app.pokCloseSprite))

    canvas.create_image(app.width*3/4, app.height*3/10, 
                        image=ImageTk.PhotoImage(app.pokFarSprite))

# Draws the text box to display battle messages below background
def drawTextBox(app, canvas):
    m = 7
    canvas.create_rectangle(0, app.bgImage.size[1], app.width, 
                            app.bgImage.size[1]+app.textBoxSize,
                            fill="grey90", width=m, outline="gold")
    font = "ComicSansMS 25"
    canvas.create_text(20, app.bgImage.size[1]+app.textBoxSize/2, anchor="w",
                       text=app.battleText, font=font, fill="black")

# Draws possible moves for your pokemon wheni n choose phase
def drawMoves(app, canvas):
    # Variables for each choose move box
    m = 10
    yTop = app.bgImage.size[1] + app.textBoxSize
    outBoxW = app.width/2
    outBoxH = (app.height-yTop)/2
    inBoxW = app.width/2 - 2*m
    inBoxH = (app.height-yTop)/2 - 2*m
    # increments to select move
    move = 0
    # Create the 4 boxes
    for row in range(2):
        for col in range(2):
            # Color is default grey, but if selected make it red
            fill = "grey48"
            if row == app.selection[0] and col == app.selection[1]:
                fill = "red"
            # Draw the outer rectangle
            canvas.create_rectangle(col*outBoxW, yTop+row*outBoxH, 
                                    (col+1)*outBoxW, yTop+(row+1)*outBoxH, 
                                    fill=fill, width=0)
            x0 = (2*col+1)*m + col*inBoxW
            y0 = yTop + (2*row+1)*m + row*inBoxH
            x1 = (2*col+1)*m + (col+1)*inBoxW
            y1 = yTop + (2*row+1)*m + (row+1)*inBoxH
            # Draw inner rectangle
            canvas.create_rectangle(x0, y0, x1, y1, fill="white", width=0)
            # Draw move in the center of rectangle
            font = "ComicSansMS 26 bold"
            moveName = app.pokClose.moves[move]
            canvas.create_text((x0+x1)/2, (y0+y1)/2, fill="black", font=font,
                                text=moveName)
            # Add power in the bottom right
            font = "ComicSansMS 19"
            canvas.create_text(x1, y1, fill="black", font=font, anchor="se",
                                text="Power:"+str(moveList[moveName]["Power"]))
            # Incrementation so draw all moves
            move += 1

# Key pressed function that calls other based on state
def battleMode_keyPressed(app, event):
    # No matter what, if z is pressed/held, speed up text
    if event.key == "z":
        app.textSpeed = 3   
    # Give diff options based on state
    if app.battleState == "Entering":
        enteringKeyPressed(app, event)
    elif app.battleState == "Choosing":
        chooseKeyPressed(app, event)
    if app.battleState == "Battle":
        battleKeyPressed(app, event)

# When in entering mode, pressing z goes to next text  
def enteringKeyPressed(app, event):
    if event.key == "x" and app.battleState == "Entering":
        if "appeared!" in app.battleText:
            app.battleText = ""
            app.newMessage = f"Go! {app.pokClose.name}!"
        elif f"Go! {app.pokClose.name}!" in app.battleText:
            app.battleText = ""
            app.newMessage = f"What will {app.pokClose.name} do?"
            app.battleState = "Choosing"

# When state is choosing
def chooseKeyPressed(app, event): 
    # Change selected move
    drow, dcol = 0, 0        
    if event.key == "Up":
        drow, dcol = -1, 0
    elif event.key == "Down":
        drow, dcol = 1, 0
    elif event.key == "Right":
        drow, dcol = 0, 1
    elif event.key == "Left":
        drow, dcol = 0, -1
    nRow = drow + app.selection[0]
    nCol = dcol + app.selection[1]
    # Don't go over possible moves
    if nRow >= 0 and nRow < 2 and nCol >= 0 and nCol < 2:
        app.selection = (nRow, nCol)

    # Once pressed x, do selected move and change state
    if (app.displayHPFar == app.pokFar.hp and event.key == "x" and 
       app.displayHPClose == app.pokClose.hp and "do?" in app.battleText):
        if app.selection[0] == 1: row = 2
        else: row = 0
        moveName = app.pokClose.moves[row + app.selection[1]]
        app.battleState = "Battle"
        setupTurn(app, moveName)
        doAttack(app, app.move0, app.first, app.second)

# Do things in battle state
def battleKeyPressed(app, event):
    # When z is pressed
    if event.key == "x":
        # If the game is over, switch back to overworld
        if "won!" in app.battleText:
            app.pokFar.hp = app.pokFar.getMaxHP()
            app.player.ownedPokemon.append(app.pokFar)
            if app.score == 5: app.mode = "endMode"
            else: app.mode = "overworldMode"
        # If someone won, make text won
        elif app.pokClose.hp <= 0: 
            app.battleText = ""
            app.newMessage = f"{app.pokFar.name} won!"
            app.score -= 1
        elif app.pokFar.hp <= 0: 
            app.pokFar.hp = 0
            app.battleText = ""
            app.newMessage = f"{app.pokClose.name} won!"
            app.score += 1
        # Do second move
        elif app.move0 in app.battleText:
            doAttack(app, app.move1, app.second, app.first)
        # After second move, switch back to choosing state (if not won)
        elif app.move1 in app.battleText:
            app.battleState = "Choosing"
            app.battleText = ""
            app.newMessage = f"What will {app.pokClose.name} do?"

# If z is not pressed, have normal text speed
def battleMode_keyReleased(app, event):
    if event.key == "z":
        app.textSpeed = 1

# Timer fired makes the pokemon bounce while choosing, text scroll when new 
# message, and makes HP bar lower
def battleMode_timerFired(app):
    # Bounce when in choose phase
    if app.battleState == "Choosing":
        if app.tickCount//5 % 2 == 0:
            app.infoY -= 2
            app.pokCloseY += 2
        else:
            app.infoY += 2
            app.pokCloseY -= 2
    # Scroll through text when new message is added
    if app.newMessage != "":
        # Textspeed changes how many chars displayed on tick
        app.battleText += app.newMessage[0:app.textSpeed]
        app.newMessage = app.newMessage[app.textSpeed:]
    # Change hp bar if the displayed and actual are not the same
    if app.displayHPClose > app.pokClose.hp and app.displayHPClose >= 0:
        app.displayHPClose -= 3
        if app.displayHPClose < app.pokClose.hp:
            app.displayHPClose = app.pokClose.hp
    elif app.displayHPFar > app.pokFar.hp and app.displayHPFar >= 0:
        app.displayHPFar -= 3
        if app.displayHPFar < app.pokFar.hp:
            app.displayHPFar = app.pokFar.hp
    app.tickCount += 1

# Sets up first turn
def setupTurn(app, moveClose):
    # Finds first and second pokemon based on their speeds
    moveFar = random.choice(app.pokFar.moves)
    if app.pokClose.speed > app.pokFar.speed:
        app.first, app.second = app.pokClose, app.pokFar
        app.move0, app.move1 = moveClose, moveFar
    else:
        app.second, app.first = app.pokClose, app.pokFar
        app.move1, app.move0 = moveClose, moveFar

# Does an attack that decreases HP
def doAttack(app, move, attacker, defender):
    # Set up variables for damage and calculations
    modATK = 0.01
    modDEF = 0.01
    moveName = move
    move = moveList[move]
    # Make sure move actually does damage
    if move["Power"] != "None":
        # Calc based on physical attributes
        if move["Category"] == "Physical":
            power = int(move["Power"])
            dmg = int(power*attacker.attack*modATK/(1+modDEF*defender.defense))
            defender.hp -= dmg
        # Calc based on special attributes
        elif move["Category"] == "Special":
            power = int(move["Power"])
            dmg = int(power*attacker.SPattack*modATK/
                      (1+modDEF*defender.SPdefense))
            defender.hp -= dmg
        # Make battle text
        app.battleText = ""
        app.newMessage = (f"{attacker.name} used {moveName}! " + 
                          f"It did {dmg} damage!")
        # Make sure damage taker doesn't drop below 0 hp
        if defender.hp < 0:
            defender.hp = 0



###############################################################################
###############################################################################
# ___________            .___ 
# \_   _____/  ____    __| _/ 
#  |    __)_  /    \  / __ |  
#  |        \|   |  \/ /_/ |  
# /_______  /|___|  /\____ |  
#         \/      \/      \/  
###############################################################################
###############################################################################

# Draw text for end game
def endMode_redrawAll(app, canvas):
    font = "ComicSansMs 150 bold"
    canvas.create_text(app.width/2, app.height/2, font=font, text="You Won!",
                        fill="black")
    instruc = "Press r to restart\nPress c to continue game"
    canvas.create_text(app.width/2, app.height*3/4, font="ComicSansMs 40", 
                       text=instruc, fill="black")

# Continue the game if c is pressed, restart if r is pressed
def endMode_keyPressed(app, event):
    if event.key == "r":
        app.mode = "startMode"
        appStarted(app)
    if event.key == "c":
        app.mode = "overworldMode"

# Main draw element
def main():
    runApp(width=693, height=693)

if __name__ == '__main__':
    main()

